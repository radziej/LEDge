// -*- C++ -*-
// Copyright [2015] <RWTH Aachen, III. Phys. Inst. A>

#include "LEDge/ledge.h"

// C++ standard libraries
#include <string>
#include <vector>
#include <utility>
#include <algorithm>

// Pxl libraries
#include "Pxl/Pxl/interface/pxl/core.hh"
#include "Pxl/Pxl/interface/pxl/hep.hh"

// Misc tools
#include "HistClass.hh"
#include "Tools/MConfig.hh"
#include "Tools/PXL/Sort.hh"
#include "LEDge/cutcontainer.h"

// ROOT libraries
#include "TFile.h"

// Cutflow method defined in cutflow.h and generated by ./python/gencutflow.py
#include "LEDge/cutflow.h"

////////////////////////////////////////
// Constructor
LEDge::LEDge(const Tools::MConfig &cfg) :
    is_data_(cfg.GetItem<bool>("General.RunOnData")),
    trigger_list(Tools::splitString<std::string>(cfg.GetItem<std::string>("Trigger.List"))),

    // File for storage of histograms
    output_file_(new TFile("histograms.root", "RECREATE")),

    // Muon ID criteria
    muoid_pt_min_                   (cfg.GetItem<double>("Muon.Pt.min")),
    muoid_eta_max_                  (cfg.GetItem<double>("Muon.Eta.max")),
    muoid_isglobalmuon_             (cfg.GetItem<bool>("Muon.HighPtID.IsGlobalMuon")),
    muoid_istrackermuon_            (cfg.GetItem<bool>("Muon.HighPtID.IsTrackerMuon")),
    muoid_ptrelativeerror_max_      (cfg.GetItem<double>("Muon.HighPtID.PtRelativeError.max")),
    muoid_nmatchedstations_min_     (cfg.GetItem<int>("Muon.HighPtID.NMatchedStations.min")),
    muoid_vhitsmuonsys_min_         (cfg.GetItem<int>("Muon.HighPtID.VHitsMuonSys.min")),
    muoid_vhitspixel_min_           (cfg.GetItem<int>("Muon.HighPtID.VHitsPixel.min")),
    muoid_trackerlayerswithmeas_min_(cfg.GetItem<int>("Muon.HighPtID.TrackerLayersWithMeas.min")),
    muoid_dxy_max_                  (cfg.GetItem<double>("Muon.HighPtID.Dxy.max")) {

  // Initialize histograms
  // Raw event counter
  HistClass::CreateHistoUnchangedName("h_counters", 10, 0, 11, "N_{events}");

  // Externally generated cutflow histogram
  HistClass::histo["h1_cutflow"] = get_cutflow_histogram();

  // n-1 muon preselection
  HistClass::CreateHisto("muopre_globalmuon",        2, -0.5, 1.5, "Global #mu");
  HistClass::CreateHisto("muopre_trackermuon",       2, -0.5, 1.5, "Tracker #mu");
  HistClass::CreateHisto("muopre_validcocktail",     2, -0.5, 1.5, "Tracker #mu");

  // n-1 muon ID
  HistClass::CreateHisto("muoid_pt",                5000, 0, 5000, "p_{T} (#mu) [GeV]");
  HistClass::CreateHisto("muoid_eta",               100, 0, 5, "#eta (#mu) [GeV]");
  HistClass::CreateHisto("muoid_ptrelativeerror",   300, 0, 3, "Tracker #mu");
  HistClass::CreateHisto("muoid_nmatchedstations",  9, -0.5, 8.5, "N_{Matched Stations}");
  HistClass::CreateHisto("muoid_trackerlayers",     20, -0.5, 19.5, "Hits_{Tracker Layers}");
  HistClass::CreateHisto("muoid_vhitsmuonsys",      56, -0.5, 55.5, "Hits_{Muon System}");
  HistClass::CreateHisto("muoid_vhitspixel",        11, -0.5, 10.5, "Hits_{Pixeldetector}");
  HistClass::CreateHisto("muoid_dxy",               1000, 0, 0.5, "D_{xy} (#mu) [cm]");

  // n-1 muon pair ID
  HistClass::CreateHisto("muopair_sign",          3, -1.5, 1.5, "sign(#mu_{1}) * sign(#mu_{2})");
  HistClass::CreateHisto("muopair_triggermatch",  2, -0.5, 1.5, "Trigger Matched");
  HistClass::CreateHisto("muopair_cosangle",      100, 0.0, 1.0, "cos #angle (#mu_{1}, #mu_{2})");
  HistClass::CreateHisto("muopair_chi2",          320, -1.5, 30.5, "#chi^{2} / Degrees of Freedom");

  HistClass::CreateHisto("m_mumu",      8000, 0, 8000, "m_{#mu#mu} [GeV]");
  HistClass::CreateHisto("m_mumu_gen",  8000, 0, 8000, "m_{#mu#mu} [GeV]");
}


////////////////////////////////////////
// Destructor
LEDge::~LEDge() {
}


////////////////////////////////////////////////////////////////////////////////
// Public Funcions

////////////////////////////////////////
// Analysis Fork Functions
void LEDge::analyseEvent(const pxl::Event *event) {
  // Set up basic particle vectors and event views
  initializeEvent(event);
  HistClass::FillStr("cutflow", "Initial Events", 1.);

  // Ensure that the required triggers have fired
  if (!selectTrigger()) {
    releaseEvent();
    return;
  }
  HistClass::FillStr("cutflow", "Trigger selection", 1.);

  // Ensure that there are at least two well reconstructed leptons
  if (!preselectLeptons()) {
    releaseEvent();
    return;
  }
  HistClass::FillStr("cutflow", "Muon Preselection", 1.);

  // Apply ZPrime single muon selection criteria
  if (!selectLeptons()) {
    releaseEvent();
    return;
  }
  HistClass::FillStr("cutflow", "Muon Selection", 1.);

  // Apply ZPrime dimuon selection criteria
  if (!selectLeptonPairs()) {
    releaseEvent();
    return;
  }
  HistClass::FillStr("cutflow", "Dimuon Selection", 1.);

  // Fill the distributions after all requirements
  fillFinalDistributions();
  HistClass::FillStr("cutflow", "Final Events", 1.);

  releaseEvent();
}


void LEDge::endJob(const Serializable *input = 0) {
  ////////////////////////////////////////
  // Print statistics of the job


  ////////////////////////////////////////
  // Write histogram files

  // cutflow
  output_file_->cd();
  HistClass::Write("cutflow");

  // n-1 preselection
  output_file_->cd();
  output_file_->mkdir("pre/");
  output_file_->cd("pre/");
  HistClass::WriteAll("muopre_");

  // n-1 muon ID
  output_file_->cd();
  output_file_->mkdir("id/");
  output_file_->cd("id/");
  HistClass::WriteAll("muoid_");

  // n-1 muon pair ID
  output_file_->cd();
  output_file_->mkdir("pair/");
  output_file_->cd("pair/");
  HistClass::WriteAll("muopair_");

  // Final distributions
  output_file_->cd();
  HistClass::Write("m_mumu");


  // Write generator information histograms
  if (!is_data_) {
    output_file_->mkdir("gen/");
    output_file_->cd("gen/");
    HistClass::WriteAll("_gen");
  }

  output_file_->Close();
  delete output_file_;
}


////////////////////////////////////////////////////////////////////////////////
// Private Methods

////////////////////////////////////////
// Event Release

// Release all variables pertaining to an event
void LEDge::releaseEvent() {
  // Note that all object deletion of pxl objects is handled by the pxl library itself

  // Clear event views
  rec_evt_view_ = nullptr;
  gen_evt_view_ = nullptr;
  tri_evt_view_ = nullptr;

  // Clear the muon candidates
  muo_candidate_1_ = nullptr;
  muo_candidate_2_ = nullptr;

  // Clear the particle vectors
  eles_.clear();
  muos_.clear();

  // Clear the pair vectors
  muo_pairs_.clear();

  if (!is_data_) {
    // Clear the gen particle vectors
    eles_gen_.clear();
    muos_gen_.clear();
  }
}


////////////////////////////////////////
// Event Initialization

// Fill the individual particle vectors from the all particle vector
void LEDge::fillParticleVector(std::vector<pxl::Particle *> *all_particles,
                               std::vector<pxl::Particle *> *electrons,
                               std::vector<pxl::Particle *> *muons) {
  // Push particles into respective vectors
  for (pxl::Particle *particle : *all_particles) {
    std::string current_name = particle->getName();
    // Fill the vector if it has the right name
    if (current_name == "Ele") {
      electrons->push_back(particle);
    } else if (current_name == "Muon") {
      muons->push_back(particle);
    }
  }
}

// Set up all the basic variables for an event
void LEDge::initializeEvent(const pxl::Event *event) {
  // Increment the event counter
  HistClass::Fill("h_counters", 1, 1);  // increment number of events

  // Setup event views
  rec_evt_view_ = event->getObjectOwner().findObject<pxl::EventView>("Rec");
  gen_evt_view_ = event->getObjectOwner().findObject<pxl::EventView>("Gen");
  tri_evt_view_ = (event->getObjectOwner().findObject<pxl::EventView>("Trig") != 0)
      ? event->getObjectOwner().findObject<pxl::EventView>("Trig")
      : event->getObjectOwner().findObject<pxl::EventView>("Rec");

  // Particle counts
  num_ele_  = rec_evt_view_->getUserRecord("NumEle");
  num_muo_  = rec_evt_view_->getUserRecord("NumMuon");

  // Load particles
  std::vector<pxl::Particle *> all_particles;
  rec_evt_view_->getObjectsOfType<pxl::Particle>(all_particles);
  pxl::sortParticles(all_particles);

  // Fill individual particle vectors
  fillParticleVector(&all_particles, &eles_, &muos_);

  if (!is_data_) {
    // Load gen particles
    std::vector<pxl::Particle *> all_gen_particles;
    gen_evt_view_->getObjectsOfType<pxl::Particle>(all_gen_particles);
    pxl::sortParticles(all_gen_particles);

    // Fill individual particle vectors
    fillParticleVector(&all_gen_particles, &eles_gen_, &muos_gen_);

    // TODO(radziej): adjust the weights when pileup information becomes available
    // Load individual weights
    double event_weight = gen_evt_view_->getUserRecord("Weight");
    // double pileup_weight = gen_evt_view_->getUserRecord_def("PUWeight", 1.);

    // Set the global weight
    weight_ = event_weight;
    // weight = event_weight * pileup_weight;
  }
}


////////////////////////////////////////
// Trigger Selection
bool LEDge::selectTrigger() {
  for (auto &us : tri_evt_view_->getUserRecords()) {
    for (auto &trigger : trigger_list) {
      if (std::string::npos != us.first.find(trigger))
        if (us.second)
          return true;
    }
  }

  return false;
}


////////////////////////////////////////
// Lepton Preselection
bool LEDge::passPreselection(pxl::Particle *muon) {
  CutContainer MuonPreselection(HistClass::histo, weight_);

  MuonPreselection.AddCut("muopre_globalmuon",
                          muon->getUserRecord("isGlobalMuon").toBool() == muoid_isglobalmuon_,
                          muon->getUserRecord("isGlobalMuon").toInt32());
  MuonPreselection.AddCut("muopre_trackermuon",
                          muon->getUserRecord("isTrackerMuon").toBool() == muoid_istrackermuon_,
                          muon->getUserRecord("isTrackerMuon").toInt32());
  MuonPreselection.AddCut("muopre_validcocktail",
                          muon->getUserRecord("validCocktail").toBool(),
                          muon->getUserRecord("validCocktail").toInt32());

  MuonPreselection.FillHistograms();
  return MuonPreselection.PassesAll();
}

// Ensure that there are at least two muons that are global, tracker and cocktail muons
bool LEDge::preselectLeptons() {
  // Loop over muons and fill n-1 histograms, before erasing the ones failing
  // the preselection
  for (auto it = muos_.begin(); it != muos_.end();) {
    if (!passPreselection(*it))
      muos_.erase(it);
    else
      ++it;
  }
  muos_.shrink_to_fit();

  return (muos_.size() >= 2);
}


////////////////////////////////////////
// Lepton Selection

// Perform the muon ID on the given particle object
bool LEDge::passMuonID(pxl::Particle *muon) {
  CutContainer MuonCuts(HistClass::histo, weight_);

  MuonCuts.AddCut("muoid_pt", muon->getPt() > muoid_pt_min_, muon->getPt());
  MuonCuts.AddCut("muoid_eta", muon->getEta() < muoid_eta_max_, muon->getEta());
  MuonCuts.AddCut("muoid_ptrelativeerror",
                  muon->getUserRecord("ptErrorCocktail").toDouble() /
                  muon->getUserRecord("ptCocktail").toDouble() <
                  muoid_ptrelativeerror_max_,
                  muon->getUserRecord("ptErrorCocktail").toDouble() /
                  muon->getUserRecord("ptCocktail").toDouble());
  MuonCuts.AddCut("muoid_nmatchedstations",
                  muon->getUserRecord("NMatchedStations").toInt32() > muoid_nmatchedstations_min_,
                  muon->getUserRecord("NMatchedStations").toDouble());
  MuonCuts.AddCut("muoid_vhitsmuonsys",
                  muon->getUserRecord("VHitsMuonSys").toInt32() > muoid_vhitsmuonsys_min_,
                  muon->getUserRecord("VHitsMuonSys").toDouble());
  MuonCuts.AddCut("muoid_vhitspixel",
                  muon->getUserRecord("VHitsPixel").toInt32() > muoid_vhitspixel_min_,
                  muon->getUserRecord("VHitsPixel").toDouble());
  MuonCuts.AddCut("muoid_trackerlayers",
                  muon->getUserRecord("TrackerLayersWithMeas").toInt32() > muoid_trackerlayerswithmeas_min_,
                  muon->getUserRecord("TrackerLayersWithMeas").toDouble());
  MuonCuts.AddCut("muoid_dxy",
                  fabs(muon->getUserRecord("DxyCocktail").toDouble()) < muoid_dxy_max_,
                  fabs(muon->getUserRecord("DxyCocktail").toDouble()));

  MuonCuts.FillHistograms();
  return MuonCuts.PassesAll();
}

// Helper function for remove/erase idiom
static bool notPassGeneratorMuonID(pxl::Particle *muon) {
  return !(muon->getPt() > 50.0 && muon->getEta());
}

// Select the lepton (muon) candidates or return false if there arent enough
bool LEDge::selectLeptons() {
  // Loop over muons and fill n-1 histograms, before erasing the ones passing
  // the ID
  for (auto it = muos_.begin(); it != muos_.end();) {
    if (!passMuonID(*it))
      muos_.erase(it);
    else
      ++it;
  }
  muos_.shrink_to_fit();

  if (!is_data_) {
    // Only leave valid generator level muons in the vector
    muos_gen_.erase(std::remove_if(muos_gen_.begin(), muos_gen_.end(), notPassGeneratorMuonID),
                       muos_gen_.end());
  }

  // When the muon did not pass the ID, fill histograms for analysis
  // TODO(radziej) write histograms
  return (muos_.size() >= 2);
}


////////////////////////////////////////
// Lepton Pair Selection
static bool compareInvariantMass(std::pair<pxl::Particle *, pxl::Particle *> pair1,
                                std::pair<pxl::Particle *, pxl::Particle *> pair2) {
  return (((pair1.first)->getVector() + (pair1.second)->getVector()).getMass() >
          ((pair2.first)->getVector() + (pair2.second)->getVector()).getMass());
}

bool LEDge::triggerMatched() {
  std::vector<pxl::Particle *> triggered_particles;
  tri_evt_view_->getObjectsOfType<pxl::Particle>(triggered_particles);

  for (auto &particle : triggered_particles) {
    for (auto &trigger : trigger_list) {
      std::string current_name = particle->getName();
      if (current_name == trigger) {
        for (auto &pair : muo_pairs_) {
          bool match = (particle->getVector().deltaR((pair.first)->getVector()) < 0.4 ||
                        particle->getVector().deltaR((pair.second)->getVector()) < 0.4);
          if (match)
            return true;
        }
      }
    }
  }

  return false;
}

bool LEDge::passMuonPairID(std::pair<pxl::Particle *, pxl::Particle *> pair) {
  CutContainer MuonPairCuts(HistClass::histo, weight_);
  pxl::Particle *muon1 = pair.first;
  pxl::Particle *muon2 = pair.second;

  // opposite sign muons
  MuonPairCuts.AddCut("muopair_sign",
                      muon1->getCharge() * muon2->getCharge() == -1,
                      muon1->getCharge() * muon2->getCharge());

  // cosmic muon suppression
  double cos_angle = (muon1->getVector() * muon2->getVector()) /
      (muon1->getVector().getMag() * muon2->getVector().getMag());
  MuonPairCuts.AddCut("muopair_cosangle",
                      cos_angle >= -0.9998,  // corresponds to (pi - 0.02) rad = 178.9 deg
                      cos_angle);

  // one object matched to trigger
  bool trigger_matched = triggerMatched();
  MuonPairCuts.AddCut("muopair_triggermatch",
                      trigger_matched,
                      trigger_matched);

  // chi2 / ndof requirement
  std::vector<pxl::Vertex *> vertices;
  rec_evt_view_->getObjectsOfType<pxl::Vertex>(vertices);
  bool vertex_match = false;
  double chi2 = -1.0;
  double ndof = -1.0;
  for (auto vtx : vertices) {
    if (vtx->getName() != "RefitVtx")
      continue;

    if ((vtx->getUserRecord("daughterId1") == muon1->getUserRecord("uniqueId") &&
         (vtx->getUserRecord("daughterId2") == muon2->getUserRecord("uniqueId"))) ||
        (vtx->getUserRecord("daughterId1") == muon2->getUserRecord("uniqueId") &&
         (vtx->getUserRecord("daughterId2") == muon1->getUserRecord("uniqueId")))) {
      vertex_match = true;
      chi2 = vtx->getUserRecord("chi2").toDouble();
      ndof = vtx->getUserRecord("ndof").toDouble();

      // std::cout << chi2 << " " << ndof << std::endl;
      break;
    }
  }


  MuonPairCuts.AddCut("muopair_chi2",
                      (vertex_match && chi2 / ndof < 10.0),
                      vertex_match ? chi2 / ndof : -1);

  MuonPairCuts.FillHistograms();
  return MuonPairCuts.PassesAll();
}

bool LEDge::selectLeptonPairs() {
  // Build muon pair vector
  for (auto it1 = muos_.begin(); it1 != muos_.end() - 1; ++it1) {
    for (auto it2 = it1 + 1; it2 != muos_.end(); ++it2) {
      muo_pairs_.push_back(std::make_pair((*it1), (*it2)));
    }
  }

  // Apply the muon pair ID criteria
  for (auto it = muo_pairs_.begin(); it != muo_pairs_.end();) {
    if (!passMuonPairID(*it))
      muo_pairs_.erase(it);
    else
      ++it;
  }

  // Sort moun pair vector
  std::sort(muo_pairs_.begin(), muo_pairs_.end(), compareInvariantMass);

  // if (muo_pairs_.size() > 2) {
  //   std::cout << "N muons " << muos_.size() << "  N pairs " << muo_pairs_.size() << std::endl;
  //   for (auto &pair : muo_pairs_) {
  //     std::cout << ((pair.first)->getVector() + (pair.second)->getVector()).getMass() << " " << std::endl;
  //   }
  // }

  return !muo_pairs_.empty();
}


////////////////////////////////////////
// Final Distributions

// Fill the final distribution histograms
void LEDge::fillFinalDistributions() {
  muo_candidate_1_ = muo_pairs_[0].first;
  muo_candidate_2_ = muo_pairs_[0].second;
  double dimuon_mass = (muo_candidate_2_->getVector() + muo_candidate_1_->getVector()).getMass();
  HistClass::Fill("m_mumu", dimuon_mass, weight_);


  if (!is_data_) {
    // double dimuon_gen_mass = (muo_gen_candidate_1_->getVector() + muo_gen_candidate_2_->getVector()).getMass();
    // HistClass::Fill("m_mumu_gen", dimuon_gen_mass, weight_);
  }
}
